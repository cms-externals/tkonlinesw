#ifndef H_FED9UDevice
#define H_FED9UDevice

#include "Fed9UDescription.hh"
#include "Fed9UVmeDevice.hh"
#include "Fed9UDeviceException.hh"
#include "Fed9UCounters.hh"
#include "Fed9UBufferedEvent.hh"
#include <csignal>
#include <sstream>
// <NAC date="30/04/2009">
#include <boost/shared_array.hpp>
// </NAC>
namespace Fed9U {
  //using.*std::ostringstream;

  std::string getFed9ULibVersion();
  unsigned    getFed9ULibVersionMajor();
  unsigned    getFed9ULibVersionMinor();

  class Fed9UDevice : public Fed9UVmeDevice {
  public:
    Fed9UDevice(const Fed9UDescription& fed9UDescription, u32 adaptorSlot=0);
    ~Fed9UDevice();
  
    //void init();
    //void start();
    //void stop();
    //u8 hasEvent();
    //void sendSoftwareTrigger();
    //void getCompleteEvent(u32* buffer, u32 bufferSize, u32& numU32sAddedToBuffer, u32& eventCount, bool blockDisable = false);
    void softReadoutLoop();
    Fed9UCounters getCounters(Fed9UAddress feChan = Fed9UAddress(0)) {
      return Fed9UCounters(getBeEventCounterStatus());
      //_fed->getChannelBufferOccupancy(feChan));
    }
    void setChannelDelay(Fed9UAddress channel, u16 value) {
      ICUTILS_VERIFY(value < 32*16)(value);
      setDelay(channel, value / 32, value % 32);
    }
    



    void setAllDelays(u8 value){
      ICUTILS_VERIFY(value < 25)(value);
      Fed9UAddress channel;
      for (u32 j=0 ; j<CHANNELS_PER_FED ; j++ ) {
	channel.setFedChannel(j);
	setDelay(channel,_fed9UDescription->getCoarseDelay(channel),((_fed9UDescription->getFineDelay(channel)+value)%25)&0x1F);
      }
    }

    Fed9UVmeDevice & getFed9UVmeDevice() { return *this; }
    Fed9UDescription & getFed9UVMEDeviceDescription() { return theLocalFedSettings; }
    Fed9UDescription & getFed9UDeviceDescription() { return *_fed9UDescription; }

    void getCompleteBufferedEvent( Fed9UBufferedEvent & bev);

    /**
     * The soak test will write to all read/write registers on the FED and then check
     * that the write was successful.
     *
     * If any errors are found they will be written to the log file. No User action is
     * required. The method takes the number of different description files to be tested.
     * The description files are generated by the class Fed9UCreateDescription. Testing
     * the EPROM doubles the time taken to run the soak test and the User is given the option
     * not to test it. It is defaulted to true, which will test the EPROM. If it is false
     * the EPROM will not be tested.
     */
    Fed9UDevice& soakTest(u32 numberOfTests, bool testEprom = true);

    Fed9UDevice& setBlockModeReadout(bool bmr) {
      _blockModeReadout = bmr;
      return *this;
    }

    bool getBlockModeReadout() {
      return _blockModeReadout;
    }

    /**
     * Fast Hardcore Purge of the event buffer.
     *
     * Removes any existing events from the buffer but does not return the number purged. This is a fast and hard core purge method!
     */
    u32 purgeEvents() noexcept(false);
    
    // <NAC date="30/04/2009"> readout of complete spy events packed with header and trailer
    // <NAC date="15/02/2010"> added 1/N mode
    /**
     * Read a complete spy event from the FED and pack with DAQ and Tk Special header. 
     * Throws if the spy channel is armed during readout (and so a complete event could not be built)
     * set allowMixedEvent to true to allow an incomplete event to be read
     * set pEventCountBeforeRead and pL1ACountBeforeRead to get the eventCount and l1aCount for the packet
     * set oneOverNMode to write the current values of the 1la and qdr total frame count registers to the packet,
     * instead of the latched ones
     */
    // <NAC date="10/02/2010"> added run number to spy data
    boost::shared_array<u8> readCompleteSpyEvent(const std::vector<bool>& delayChipsEnabled, const u32 lvl1ID, 
                                                 const uint32_t runNumber = 0,
                                                 const bool allowMixedEvent = false,
                                                 u32* pEventCountBeforeRead = NULL, u32* pL1ACountBeforeRead = NULL,
                                                 const bool oneOverNMode = false) noexcept(false);
    // </NAC>
    // </NAC>
    // </NAC>

  private:
    Fed9UDevice(const Fed9UDevice &);
    Fed9UDevice & operator = (const Fed9UDevice &);
    // <NAC date="23/05/2007"> changed to auto_ptr to avoid leaks in contructor when an exception is thrown
    std::auto_ptr<Fed9UDescription> _fed9UDescription;
    // </NAC>
    //Fed9UVmeDevice* _fed;
    u32 _eventNumber;
    static volatile bool _isTakingData;
    static void ControlCHandler(int);
    typedef void (*sighandler_t)(int);
    sighandler_t _oldHandler;
    std::ostringstream _errorStr;
    bool _blockModeReadout;

    /**
     *
     * Routines for TrimDAC auto calibration are below here.
     * added by M. Noy, 09-03-2004.
     *
     */
  public:
  

    /**
     * Description:
     *
     * This function will try to set the appropriate TrimDAC setting
     * on each enabled FED channel individually, where the data
     * go depends on the value of mode (see below).
     *
     *
     *
     * Requires: init() to have been called.
     *           inputs/fibres should be dark
     *
     *
     * Arguments:
     *
     *         mode: Argument that decides how the calibrated
     *               values are dealt with after the calibration
     *               finishes.
     *
     *               mode==0: FED is left in calibrated config.
     *                        and the Fed9UDescription in
     *                        Fed9UVmeDevice is updated.
     *
     *               mode==1: Values originally placed in FED are
     *                        restored after calibration and calibration
     *                        results are placed in the Fed9UDescription
     *                        belonging to Fed9UDevice.
     *
     *
     *         UpperThresh: ADC count level that signal must be
     *                      below to be considered calibrated.
     *         LowerThresh: ADC count level that signal must be
     *                      above to be considered calibrated.
     *
     *
     *
     * M. Noy
     * 09-03-2004 Initial
     * 22-03-2004 Default arguments added 
     *
     */

    void trimDACInternalCalibration(u16 mode=0, u16 UpperThresh=60, u16 LowerThresh=30);
  
private:
  
    /**
     * This function will estimate the TrimDAC offset 
     * that should place a dark channel in the centre 
     * of the ADC dynamic range for given OptoRX settings. 
     * It should remain private since it is for 
     * FED internal calibration use.
     *
     * Arguments:
     * u16 Xpre: OptoRX Input Offset Current
     * u16 Xpost: OptoRX Output Offset Current
     * u16 Rload: OptoRX Load Resistor Value (Ohms)
     *
     * return: TrimDAC Offset count.
     *
     * M. Noy 
     * 09-03-2004
     */
    u16 estimateTrimDACStartPoint(u16 Xpre, u16 Xpost, u16 Rload);
    
    /**
     * This function should not exist.
     * 
     * I requested that the pre- and post- OptoRX offsets be obtainable
     * separately for a reason, and it seems that they aren't.
     * 
     *
     * M. Noy 
     * 09-03-2004
     */
    void separateOptoRXOffsets(u16 combined, u16 & Xpre, u16 & Xpost);
    
    /**
     * This function evaulates whether the internal TrimDAC calibration has finished.
     *
     * Arguments:
     *
     * vector<u16> & status: vetor of status bits
     *
     * returns: 
     * u8: with result of evaluation. 
     * 
     * M. Noy 
     * 09-03-2004
     */
    u8 trimDACCalibrationHasFinished(const vector<u16> & status);
    
    
    /**
     * This function fills the reference with an event for 
     * the TrimDAC internal calibration.
     * 
     * Arguments:
     *
     * Fed9UBufferedEvent * ev
     *
     * M. Noy 
     * 10-03-2004
     */
    void getTrimDACCalibrationEvent(Fed9UBufferedEvent & ev);
    
      
    /**
     * This function calculates a u16 casted mean of a vector
     * of scope mode data for the TrimDAC internal calibration
     * 
     * Arguments:
     * vector<u16> & data): vector holding the data.
     * 
     *
     * M. Noy 
     * 10-03-2004
     */
    u16 getTrimDACCalibrationChannelMean(vector<u16> & data);
    

  };
}

#endif // H_FED9UDevice
